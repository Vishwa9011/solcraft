/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
   combineCodec,
   fixDecoderSize,
   fixEncoderSize,
   getBytesDecoder,
   getBytesEncoder,
   getProgramDerivedAddress,
   getStructDecoder,
   getStructEncoder,
   getU64Decoder,
   getU64Encoder,
   transformEncoder,
   type AccountMeta,
   type AccountSignerMeta,
   type Address,
   type FixedSizeCodec,
   type FixedSizeDecoder,
   type FixedSizeEncoder,
   type Instruction,
   type InstructionWithAccounts,
   type InstructionWithData,
   type ReadonlyAccount,
   type ReadonlySignerAccount,
   type ReadonlyUint8Array,
   type TransactionSigner,
   type WritableAccount,
} from '@solana/kit';
import { SOLCRAFT_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const WITHDRAW_FROM_FAUCET_DISCRIMINATOR = new Uint8Array([210, 45, 219, 228, 136, 215, 104, 111]);

export function getWithdrawFromFaucetDiscriminatorBytes() {
   return fixEncoderSize(getBytesEncoder(), 8).encode(WITHDRAW_FROM_FAUCET_DISCRIMINATOR);
}

export type WithdrawFromFaucetInstruction<
   TProgram extends string = typeof SOLCRAFT_PROGRAM_ADDRESS,
   TAccountFaucetConfig extends string | AccountMeta<string> = string,
   TAccountTreasuryAta extends string | AccountMeta<string> = string,
   TAccountRecipientAta extends string | AccountMeta<string> = string,
   TAccountRecipient extends string | AccountMeta<string> = string,
   TAccountTokenProgram extends string | AccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
   TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
   InstructionWithData<ReadonlyUint8Array> &
   InstructionWithAccounts<
      [
         TAccountFaucetConfig extends string ? WritableAccount<TAccountFaucetConfig> : TAccountFaucetConfig,
         TAccountTreasuryAta extends string ? WritableAccount<TAccountTreasuryAta> : TAccountTreasuryAta,
         TAccountRecipientAta extends string ? WritableAccount<TAccountRecipientAta> : TAccountRecipientAta,
         TAccountRecipient extends string
            ? ReadonlySignerAccount<TAccountRecipient> & AccountSignerMeta<TAccountRecipient>
            : TAccountRecipient,
         TAccountTokenProgram extends string ? ReadonlyAccount<TAccountTokenProgram> : TAccountTokenProgram,
         ...TRemainingAccounts,
      ]
   >;

export type WithdrawFromFaucetInstructionData = {
   discriminator: ReadonlyUint8Array;
   amount: bigint;
};

export type WithdrawFromFaucetInstructionDataArgs = { amount: number | bigint };

export function getWithdrawFromFaucetInstructionDataEncoder(): FixedSizeEncoder<WithdrawFromFaucetInstructionDataArgs> {
   return transformEncoder(
      getStructEncoder([
         ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
         ['amount', getU64Encoder()],
      ]),
      value => ({
         ...value,
         discriminator: WITHDRAW_FROM_FAUCET_DISCRIMINATOR,
      })
   );
}

export function getWithdrawFromFaucetInstructionDataDecoder(): FixedSizeDecoder<WithdrawFromFaucetInstructionData> {
   return getStructDecoder([
      ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
      ['amount', getU64Decoder()],
   ]);
}

export function getWithdrawFromFaucetInstructionDataCodec(): FixedSizeCodec<
   WithdrawFromFaucetInstructionDataArgs,
   WithdrawFromFaucetInstructionData
> {
   return combineCodec(getWithdrawFromFaucetInstructionDataEncoder(), getWithdrawFromFaucetInstructionDataDecoder());
}

export type WithdrawFromFaucetAsyncInput<
   TAccountFaucetConfig extends string = string,
   TAccountTreasuryAta extends string = string,
   TAccountRecipientAta extends string = string,
   TAccountRecipient extends string = string,
   TAccountTokenProgram extends string = string,
> = {
   faucetConfig?: Address<TAccountFaucetConfig>;
   treasuryAta: Address<TAccountTreasuryAta>;
   recipientAta: Address<TAccountRecipientAta>;
   recipient: TransactionSigner<TAccountRecipient>;
   tokenProgram?: Address<TAccountTokenProgram>;
   amount: WithdrawFromFaucetInstructionDataArgs['amount'];
};

export async function getWithdrawFromFaucetInstructionAsync<
   TAccountFaucetConfig extends string,
   TAccountTreasuryAta extends string,
   TAccountRecipientAta extends string,
   TAccountRecipient extends string,
   TAccountTokenProgram extends string,
   TProgramAddress extends Address = typeof SOLCRAFT_PROGRAM_ADDRESS,
>(
   input: WithdrawFromFaucetAsyncInput<
      TAccountFaucetConfig,
      TAccountTreasuryAta,
      TAccountRecipientAta,
      TAccountRecipient,
      TAccountTokenProgram
   >,
   config?: { programAddress?: TProgramAddress }
): Promise<
   WithdrawFromFaucetInstruction<
      TProgramAddress,
      TAccountFaucetConfig,
      TAccountTreasuryAta,
      TAccountRecipientAta,
      TAccountRecipient,
      TAccountTokenProgram
   >
> {
   // Program address.
   const programAddress = config?.programAddress ?? SOLCRAFT_PROGRAM_ADDRESS;

   // Original accounts.
   const originalAccounts = {
      faucetConfig: { value: input.faucetConfig ?? null, isWritable: true },
      treasuryAta: { value: input.treasuryAta ?? null, isWritable: true },
      recipientAta: { value: input.recipientAta ?? null, isWritable: true },
      recipient: { value: input.recipient ?? null, isWritable: false },
      tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
   };
   const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;

   // Original args.
   const args = { ...input };

   // Resolve default values.
   if (!accounts.faucetConfig.value) {
      accounts.faucetConfig.value = await getProgramDerivedAddress({
         programAddress,
         seeds: [
            getBytesEncoder().encode(new Uint8Array([102, 97, 117, 99, 101, 116, 95, 99, 111, 110, 102, 105, 103])),
         ],
      });
   }
   if (!accounts.tokenProgram.value) {
      accounts.tokenProgram.value =
         'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
   }

   const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
   return Object.freeze({
      accounts: [
         getAccountMeta(accounts.faucetConfig),
         getAccountMeta(accounts.treasuryAta),
         getAccountMeta(accounts.recipientAta),
         getAccountMeta(accounts.recipient),
         getAccountMeta(accounts.tokenProgram),
      ],
      data: getWithdrawFromFaucetInstructionDataEncoder().encode(args as WithdrawFromFaucetInstructionDataArgs),
      programAddress,
   } as WithdrawFromFaucetInstruction<
      TProgramAddress,
      TAccountFaucetConfig,
      TAccountTreasuryAta,
      TAccountRecipientAta,
      TAccountRecipient,
      TAccountTokenProgram
   >);
}

export type WithdrawFromFaucetInput<
   TAccountFaucetConfig extends string = string,
   TAccountTreasuryAta extends string = string,
   TAccountRecipientAta extends string = string,
   TAccountRecipient extends string = string,
   TAccountTokenProgram extends string = string,
> = {
   faucetConfig: Address<TAccountFaucetConfig>;
   treasuryAta: Address<TAccountTreasuryAta>;
   recipientAta: Address<TAccountRecipientAta>;
   recipient: TransactionSigner<TAccountRecipient>;
   tokenProgram?: Address<TAccountTokenProgram>;
   amount: WithdrawFromFaucetInstructionDataArgs['amount'];
};

export function getWithdrawFromFaucetInstruction<
   TAccountFaucetConfig extends string,
   TAccountTreasuryAta extends string,
   TAccountRecipientAta extends string,
   TAccountRecipient extends string,
   TAccountTokenProgram extends string,
   TProgramAddress extends Address = typeof SOLCRAFT_PROGRAM_ADDRESS,
>(
   input: WithdrawFromFaucetInput<
      TAccountFaucetConfig,
      TAccountTreasuryAta,
      TAccountRecipientAta,
      TAccountRecipient,
      TAccountTokenProgram
   >,
   config?: { programAddress?: TProgramAddress }
): WithdrawFromFaucetInstruction<
   TProgramAddress,
   TAccountFaucetConfig,
   TAccountTreasuryAta,
   TAccountRecipientAta,
   TAccountRecipient,
   TAccountTokenProgram
> {
   // Program address.
   const programAddress = config?.programAddress ?? SOLCRAFT_PROGRAM_ADDRESS;

   // Original accounts.
   const originalAccounts = {
      faucetConfig: { value: input.faucetConfig ?? null, isWritable: true },
      treasuryAta: { value: input.treasuryAta ?? null, isWritable: true },
      recipientAta: { value: input.recipientAta ?? null, isWritable: true },
      recipient: { value: input.recipient ?? null, isWritable: false },
      tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
   };
   const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;

   // Original args.
   const args = { ...input };

   // Resolve default values.
   if (!accounts.tokenProgram.value) {
      accounts.tokenProgram.value =
         'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
   }

   const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
   return Object.freeze({
      accounts: [
         getAccountMeta(accounts.faucetConfig),
         getAccountMeta(accounts.treasuryAta),
         getAccountMeta(accounts.recipientAta),
         getAccountMeta(accounts.recipient),
         getAccountMeta(accounts.tokenProgram),
      ],
      data: getWithdrawFromFaucetInstructionDataEncoder().encode(args as WithdrawFromFaucetInstructionDataArgs),
      programAddress,
   } as WithdrawFromFaucetInstruction<
      TProgramAddress,
      TAccountFaucetConfig,
      TAccountTreasuryAta,
      TAccountRecipientAta,
      TAccountRecipient,
      TAccountTokenProgram
   >);
}

export type ParsedWithdrawFromFaucetInstruction<
   TProgram extends string = typeof SOLCRAFT_PROGRAM_ADDRESS,
   TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
   programAddress: Address<TProgram>;
   accounts: {
      faucetConfig: TAccountMetas[0];
      treasuryAta: TAccountMetas[1];
      recipientAta: TAccountMetas[2];
      recipient: TAccountMetas[3];
      tokenProgram: TAccountMetas[4];
   };
   data: WithdrawFromFaucetInstructionData;
};

export function parseWithdrawFromFaucetInstruction<
   TProgram extends string,
   TAccountMetas extends readonly AccountMeta[],
>(
   instruction: Instruction<TProgram> & InstructionWithAccounts<TAccountMetas> & InstructionWithData<ReadonlyUint8Array>
): ParsedWithdrawFromFaucetInstruction<TProgram, TAccountMetas> {
   if (instruction.accounts.length < 5) {
      // TODO: Coded error.
      throw new Error('Not enough accounts');
   }
   let accountIndex = 0;
   const getNextAccount = () => {
      const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
      accountIndex += 1;
      return accountMeta;
   };
   return {
      programAddress: instruction.programAddress,
      accounts: {
         faucetConfig: getNextAccount(),
         treasuryAta: getNextAccount(),
         recipientAta: getNextAccount(),
         recipient: getNextAccount(),
         tokenProgram: getNextAccount(),
      },
      data: getWithdrawFromFaucetInstructionDataDecoder().decode(instruction.data),
   };
}
